\chapter{Subtyping algorithm}

\begin{singlespace}
\begin{multicols}{2}
\begin{lstlisting}[style=customjulia]
abstract Ty

type TypeName
  super::Ty
  TypeName() = new()
end

type TagT <: Ty
  name::TypeName
  params
  vararg::Bool
end

type UnionT <: Ty
  a; b
end

type Var
  lb; ub
end

type UnionAllT <: Ty
  var::Var
  T
end
\end{lstlisting}
\end{multicols}

\vspace{-3ex}
\begin{lstlisting}[style=customjulia]
## Any, Bottom, and Tuple
const AnyT = TagT(TypeName(), ());  AnyT.name.super = AnyT
type BottomTy <: Ty; end; const BottomT = BottomTy()
const TupleName = TypeName(); TupleName.super = AnyT

## type application
inst(t::TagT) = t
inst(t::UnionAllT, param) = subst(t.T, Dict{Any,Any}(t.var => param))
inst(t::UnionAllT, param, rest...) = inst(inst(t,param), rest...)
super(t::TagT) = inst(t.name.super, t.params...)

extend(d::Dict, k, v) = (x = copy(d); x[k]=v; x)
subst(t,          env) = t
subst(t::TagT,    env) =
  t===AnyT ? t : TagT(t.name, map(x->subst(x,env), t.params), t.vararg)
subst(t::UnionT,  env) = UnionT(subst(t.a,env), subst(t.b,env))
subst(t::Var,     env) = get(env, t, t)
function subst(t::UnionAllT, env)
  newVar = Var(subst(t.var.lb,env), subst(t.var.ub,env))
  UnionAllT(newVar, subst(t.T, extend(env, t.var, newVar)))
end

rename(t::UnionAllT) = let v = Var(t.var.lb, t.var.ub)
  UnionAllT(v, inst(t,v))
end

type Bounds
  lb; ub       # current lower and upper bounds of a Var
  depth::Int   # invariant nesting depth of a Var's UnionAll
  right::Bool  # this Var is on the right-hand side of A <: B
end

type UnionSearchState
  i::Int       # (0 <= i < nbits(idxs))
  idxs::Int64  # bit vector representing combination being tested
  UnionSearchState() = new(0,0)
end

type UnionState
  depth::Int        # number of union decision points we're inside
  nnew::Int         # # unions found at next nesting depth
  stack::Vector{UnionSearchState}  # stack of decisions for each depth
  UnionState() = new(1,0,UnionSearchState[])
end

type Env
  vars::Dict{Var,Bounds}
  depth::Int
  Lunions::UnionState
  Runions::UnionState
  Env() = new(Dict{Var,Bounds}(), 1, UnionState(), UnionState())
end

issub(x, y) = forall_exists_issub(x, y, Env(), 0)
issub(x, y, env)         = (x === y)
issub(x::Ty, y::Ty, env) = (x === y) || x === BottomT

function forall_exists_issub(x, y, env, nL)
  for forall in 1:(1<<nL)
    if !isempty(env.Lunions.stack)
      env.Lunions.stack[end].idxs = forall
    end

    !exists_issub(x, y, env, 0) && return false

    if env.Lunions.nnew > 0
      push!(env.Lunions.stack, UnionSearchState())
      sub = forall_exists_issub(x, y, env, env.Lunions.nnew)
      pop!(env.Lunions.stack)
      !sub && return false
    end end
  return true
end

function exists_issub(x, y, env, nR)
  for exists in 1:(1<<nR)
    if !isempty(env.Runions.stack)
      env.Runions.stack[end].idxs = exists
    end
    for ru in env.Runions.stack; ru.i = -1; end
    for lu in env.Lunions.stack; lu.i = -1; end
    env.Lunions.depth = env.Runions.depth = 1
    env.Lunions.nnew = env.Runions.nnew = 0

    sub = issub(x, y, env)

    if env.Lunions.nnew > 0
      return true # return up to forall_exists_issub
    end
    if env.Runions.nnew > 0
      push!(env.Runions.stack, UnionSearchState())
      found = exists_issub(x, y, env, env.Runions.nnew)
      pop!(env.Runions.stack)
      if env.Lunions.nnew > 0
        return true # return up to forall_exists_issub
      end
    else
      found = sub
    end
    found && return true
  end
  return false
end

function issub_union(t::Ty, u::UnionT, env, R, state::UnionState)
  if state.depth > length(state.stack)
    # at a new nesting depth, begin by just counting unions
    state.nnew += 1
    return true
  end
  ui = state.stack[state.depth]; ui.i += 1
  state.depth += 1
  choice = u.((ui.idxs&(1<<ui.i)!=0) + 1)
  ans = R ? issub(t, choice, env) : issub(choice, t, env)
  state.depth -= 1
  return ans
end

issub(a::UnionT, b::UnionT, env) =
  issub_union(a, b, env, true, env.Runions)
issub(a::UnionT, b::Ty, env) =
  issub_union(b, a, env, false, env.Lunions)
issub(a::Ty, b::UnionT, env) =
  a === BottomT || issub_union(a, b, env, true, env.Runions)

function issub(a::TagT, b::TagT, env)
  a === b && return true
  b === AnyT && return true
  a === AnyT && return false
  a.name !== b.name && return issub(super(a), b, env)
  if a.name === TupleName
    va, vb = a.vararg, b.vararg
    la, lb = length(a.params), length(b.params)
    if va && (!vb || la < lb)
      return false
    end
    ai = bi = 1
    while true
      ai > la && return bi > lb || (bi==lb && vb)
      bi > lb && return false
      !issub(a.params[ai], b.params[bi], env) && return false
      ai==la && bi==lb && va && vb && return true
      if ai < la || !va
        ai += 1
      end
      if bi < lb || !vb
        bi += 1
      end end
  else
    env.depth += 1  # crossing invariant constructor, increment depth
    yes = true
    for i = 1:length(a.params)
      ai, bi = a.params[i], b.params[i]
      yes &= (issub(ai, bi, env) && issub(bi, ai, env))
    end
    env.depth -= 1
    return yes
  end
end

function issub(a::Var, b::Ty, env)
  aa = env.vars[a]
  # Vars are fully checked by the "forward" direction of A<:B in
  # invariant position.
  aa.right && return true
  return issub(aa.ub, b, env) && (env.depth == aa.depth ||
                                  issub(b, aa.lb, env))
end

lb(x, env) = isa(x,Var) ? lb(env.vars[x].lb, env) : x
ub(x, env) = isa(x,Var) ? ub(env.vars[x].ub, env) : x
join(a,b,env) = issub(a,b,env) ? b : issub(b,a,env) ? a : UnionT(a,b)

function issub(a::Union(Ty,Var), b::Var, env)
  bb = env.vars[b]
  !bb.right && return true
  if isa(a,Var)
    aa = env.vars[a]
    aa.right && return true
    # Vars must occur at same depth
    aa.depth != bb.depth && return false
    a_lb, a_ub = ub(aa.lb,env), lb(aa.ub,env)
  else
    a_lb, a_ub = a, a
  end
  b_lb, b_ub = ub(bb.lb,env), lb(bb.ub,env)
  # make sure constraint is within the current bounds of Var
  if !isa(bb.lb,Var) && !isa(bb.ub,Var)
    !issub(a_ub, b_ub, env) && return false
    if env.depth > bb.depth
      !issub(b_lb, a_lb, env) && return false
    end end

  # check & update bounds for covariant position
  # for each type a<:b, grow b's lower bound to include a, or set b's
  # lower bound equal to a typevar if its lower bound is big enough.
  if isa(a,Var) && (a === bb.lb || issub(b_lb, a_lb, env))
    bb.lb = a
  else
    !issub(a_ub, b_ub, env) && return false
    bb.lb = join(b_lb, a_ub, env)
  end

  if env.depth > bb.depth
    # check & update bounds for invariant position.
    # this would be the code for contravariant position, but since
    # we only have invariant, the covariant code above always runs too.
    if isa(a,Var) && (a === bb.ub || issub(a_ub, b_ub, env))
      bb.ub = a
    else
      # for true contravariance we would need to compute a meet here,
      # but because of invariance b_ub~$\sqcap$~a_lb = a_lb here always
      bb.ub = a_lb
    end end
  return true
end

function issub_unionall(t::Ty, u::UnionAllT, env, R)
  haskey(env.vars, u.var) && (u = rename(u))
  env.vars[u.var] = Bounds(u.var.lb, u.var.ub, env.depth, R)
  ans = R ? issub(t, u.T, env) : issub(u.T, t, env)
  delete!(env.vars, u.var)
  return ans
end

issub(a::UnionAllT, b::UnionAllT, env) = issub_unionall(a, b, env, true)
issub(a::UnionT, b::UnionAllT, env) = issub_unionall(a, b, env, true)
issub(a::UnionAllT, b::UnionT, env) = issub_unionall(b, a, env, false)
issub(a::Ty, b::UnionAllT, env) =
  a === BottomT || issub_unionall(a, b, env, true)
issub(a::UnionAllT, b::Ty, env) = issub_unionall(b, a, env, false)

\end{lstlisting}
\end{singlespace}
