% -*- Mode:TeX -*-

%% The documentclass options along with the pagestyle can be used to generate
%% a technical report, a draft copy, or a regular thesis.  You may need to
%% re-specify the pagestyle after you \include  cover.tex.  For more
%% information, see the first few lines of mitthesis.cls. 

\documentclass[12pt]{mitthesis}
\usepackage{lgrind}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amsopn}
\usepackage[nottoc]{tocbibind}
\pagestyle{plain}

\DeclareMathOperator{\find}{find}
\DeclareMathOperator{\conform}{conform}
\DeclareMathOperator{\subtype}{subtype}
\DeclareMathOperator{\typeof}{typeof}
\DeclareMathOperator{\eval}{eval}
\DeclareMathOperator{\interpret}{interpret}
\DeclareMathOperator{\incomplete}{incomplete}
%\DeclareMathOperator{\choose}{choose}
\DeclareMathOperator{\length}{length}
\DeclareMathOperator{\recall}{recall}
%\DeclareMathOperator{\empty}{empty}
\DeclareMathOperator{\tail}{tail}
\DeclareMathOperator{\Frame}{Frame}
\DeclareMathOperator{\extend}{extend}
\DeclareMathOperator{\super}{super}
\DeclareMathOperator{\p}{p}
\DeclareMathOperator{\last}{last}
\DeclareMathOperator{\typename}{typename}
\DeclareMathOperator{\intersect}{intersect}
\DeclareMathOperator{\formals}{formals}
\DeclareMathOperator{\superdecl}{super\_decl}

%% This bit allows you to either specify only the files which you wish to
%% process, or `all' to process all files which you \include.
%% Krishna Sethuraman (1990).

%\typein [\files]{Enter file names to process, (chap1,chap2 ...), or `all' to
%process all files:}
%\def\all{all}
%\ifx\files\all \typeout{Including all files.} \else \typeout{Including only \files.} \includeonly{\files} \fi

\begin{document}

\include{cover}
\pagestyle{plain}
\include{contents}

\part{Introduction}
\begin{quotation}
Must answer at a high level: Why a new language?

Historical, technical and application level aspects
\end{quotation}

\chapter{A brief history of technical computing}
\begin{quotation}
Technical computing today is an unwieldy hybrid of computing modalities

Descendants of the EDSAC (1951) era of batch processing. ``Job queue''

Fortran (1957), the first compiled high level language with performance
comparable to assembler. First designed for scientific computing,
but use spread also to business applications. Distinction between
high- and low-level languages.

Recap: how relevant is our historical baggage?

Distinction between interactive and batch computing modes

Distinction between low-level assembler and high-level
\end{quotation}

\chapter{Technical aspects}
\begin{quotation}
How do you take all the indexing and other core functionality of a
language and throw domain theory and llvm compiler analysis at it?

How much of the past 30 years of handwritten Matlab internals can
be autogenerated with a compiler? (A lot)

Can now get past traditional classifications of language boundaries
- interpreted vs. compiled, high-level vs. low-level, procedural vs.
imperative vs. functional, etc.
\end{quotation}

\part{Technical Merits}
\begin{quotation}
Why is Julia fast?

How does Julia break through the 4x-slower-than-C performance barrier?
\end{quotation}

\chapter{Type System}


\section{Domain Theory}

Review of what everybody knows (but not alan and jiahao)


\subsection{Classification of languages}

\begin{tabular}{|c||c|c|}
\hline 
 & Typed & No/few types\tabularnewline
\hline 
\hline 
Dynamic & Dylan, Julia & Lots\tabularnewline
\hline 
Static & Haskell & C\tabularnewline
\hline 
\end{tabular}


\section{Dynamic type inference}
\begin{quotation}
Joins of quantified types

``Diagonal dispatch''

(T,T) (Int, Real)

\textbackslash{}(Int,Int)/

Avoid hard coding logic into the compiler.
\end{quotation}

\section{Exposing to the user what is part of the language anyway and not
just hiding it in the compiler.}
\begin{quotation}
Data flow analysis has to actually work

Taking things out of the language that break dataflow analysis

Local reasoning

You are imposing a type system anyway, even implicitly perhaps, so
might as well make that from the get-go.
\end{quotation}

\section{Objections to dynamic typing and counterarguments}


\subsection{10 reasons why people like Matlab from a dynamic typing}


\subsection{Users initially don't want types, but eventually become happy to
use them once they realized what it did for them}


\section{The fallacy of duck typing}
\begin{quotation}
The double entendre of ``duck typing''

- Walk like a duck, quack like a duck

- Ducking the issue of typing altogether - why this isn't possible
IRL

Case in point: Python and NumPy.

NumPy tried to work within the confines of Python, but has more or
less failed for technical and political reasons. (Technical: hard
to work with types in language that deliberately tries to obscure
them from the user. Political: unwillingness to fix broken package
distribution system.) Consequences: Numba and Numba\_lang, Anaconda.
Essentially reinventing types in ``Python''. 
\end{quotation}

\chapter{How LLVM JIT compilation makes this practical}
\begin{quotation}
but just can\textquoteright{}t sprinkle llvm dust to make it fast
---- many people would think you\textquoteright{}d have to do a lot
more, but llvm solves this technical problem
\end{quotation}

\section{Reusing compiler infrastructure}
\begin{quotation}
e.g. optimizations

Other platforms with similar ideas: M\$ CIL for .NET - why is LLVM
better?
\end{quotation}

\section{Different tradeoffs between memory and flops (see sociology)}


\section{Code introspection}
\begin{quotation}
Ability to zoom in on many representations

Julia as a both high- and low-level language
\end{quotation}

\section{Metaprogramming}
\begin{quotation}
True macros
\end{quotation}

\section{Parallel Computing Language Theory}
\begin{quotation}
Paradigm-agnostic

Everyone knows parallel computing is broken

Parallelism at the level of primitive operations
\end{quotation}

\section{Miscellaneous Puzzle Pieces}


\part{Case Studies}


\chapter{ACAS}


\chapter{JUMP}

Metaprogramming tools reused for symbolic algebra


\chapter{Numerical Linear Algebra}

Multiple dispatch on special matrices


\chapter{Parallel Computing Case Studies, e.g. parallel prefix}


\chapter{IJulia}


\part{Human aspects of computing}
\begin{quotation}
How social phenomena is shaped by technical limitations

Software business is based on imposing restrictions
\end{quotation}

\section{A brief history of technical computing}
\begin{quotation}
Recap: how relevant is our historical baggage?

Distinction between interactive and batch computing modes

Distinction between low-level assembler and high-level
\end{quotation}

\section{Code publication}
\begin{quotation}
How have things changed since the early days of tape archives and
punch card depositories?

Matlab as the publisher and consolidator of numerical algorithms

Github democratizes the publishing of code written in computer languages,
much like how blogs democratized the publishing of prose written in
human languages.

Also, ancillary things like Travis CI - scientific code is woefully
undertested.
\end{quotation}

\section{Why Julia is a product of its time}
\begin{quotation}
Use more memory, different point now in the resource/cost space

In line with the new big data world of today?

Julia is the language where people can and hopefully will collaborate
to make better programs (different from 1980).

Language has to not just know matrices, but also must be a web server
and everything in between. (MATLAB knew it was also FFT and graphical,
but the line was drawn)

Want to get past only the experts knowing how to use arpack, lapack,
etc.

Prediction: the next ARPACK like thing will have one tenth the number
of lines and have many more innovations and contributors (BLAS and
lapack already have 4x redundancy thanks to single, double, complex,
double complex repetition of routines)
\end{quotation}

\part{Julia today}
\begin{quotation}
A nominal conclusion

Here is a snapshot of Julia in April, 2014

Show all the stuff that will be fun to look at because it\textquoteright{}ll
be so antiquated by 2019\end{quotation}

%\include{chap1}
%\include{chap2}
%\include{chap3}
%\include{chap4}
%\include{chap5}
%\include{chap6}
%\include{chap7}
\begin{singlespace}
\include{biblio}
\end{singlespace}
%\appendix
%\include{appa}
%\include{appb}
\end{document}
