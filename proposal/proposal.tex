\documentclass[12pt]{article}
\usepackage{fullpage}
\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fill in the following information and compile to create your very
% own EECS thesis proposal.  Thesis not included.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\def\author{Jeffrey Werner Bezanson}
\def\addressone{}
\def\addresstwo{}

\def\supervisor{Alan Edelman}

\def\title{Abstraction in Technical Computing}
\def\expectedcompletetiondate{May 2, 2014}
\def\briefproblemstatement{

Array-based programming environments are popular for scientific and
technical computing.
These systems consist of built-in function libraries paired with high-level
languages for interaction.
Although the libraries perform well, it is widely believed that scripting in these
languages is necessarily slow, and that only heroic feats of engineering can at
best partially ameliorate this problem.

In this thesis I argue that what is really needed is a more coherent
structure for this functionality. For this role I propose an abstraction
based on an extended version of generic functions. The novelty of this
mechanism is that it is both flexible enough to describe the wide
variety of behaviors users need in practice, while also providing
enough information to a compiler to yield good performance.


% Technical computing is characterized by great diversity and
% a rapid pace of change.

% dynamic flexibility is a good way to think about technical computing
% as a whole

% we don't know what people will want in the future, but
% a good way to try to provide for it is to at least be able
% to describe and implement what we want now. most systems
% can't even do this.

%Due to the great diversity and pace of change in technical applications,
%users would like to be able to extend and modify such systems.
%However, most of the functionality of these systems is ``built in'',
%% (rigidly defined?)
%and difficult to extend in a way that retains good performance.


%- adding a coherent structure to all the functionality, not just
%  an interface on top
%- develop a new methodology for creating one of these environments,
%  which extends to using it.


% must say something about: the key challenge is to provide the full
% rich behaviors that users expect.


%adding a coherent structure
%expressing everything with a uniform multimethod paradigm
%imagining multimethods as a solution to this, it also has to be
%extended
%if we extended multimethods in certain ways, they could solve this

%in order to motivate it you have to talk about technical computing,
%since that use case demands it.

%we want to implement technical computing within a uniform abstract
%framework. we invented a mechanism for doing that. 

%rather than taking multimethods as a fancy feature, we use it as the
%structural foundation of the system.

%expressive method signatures are simultaneously useful for the behavior
%they specify, and for the information they provide the compiler.

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Macros and whatnot to generate all the forms. 
% Macros written by David Liben-Nowell; last modified 7 February 2005.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}
\def\signatureline{\rule{2.5in}{0.25pt}}

\def\mitheader#1{
\begin{center}
  \textsc{massachusetts institute of technology}\\
  Department of Electrical Engineering and Computer Science\\
  Cambridge, Massachusetts~~02139\\[2ex]
  
  \textbf{#1}
\end{center}
}

\def\tofromheader#1{

\begin{tabular}{ll}
To:  & Department Graduate Committee \\
From: & #1 \\
\end{tabular}

}



\def\thesisproposalform{
\begin{center}
Massachusetts Institute of Technology

Department of Electrical Engineering and Computer Science

\bigskip

Proposal for Thesis Research in Partial Fulfillment

of the Requirements for the Degree of 

Doctor of Philosophy
\end{center}

\bigskip

Title:  \title

Submitted by: \hfill
\begin{tabular}[t]{p{0.3\textwidth}p{0.4\textwidth}}
\author & \signatureline \\
\addressone & (Signature of author) \\
\addresstwo \\
\end{tabular}

Date of submission:  \today

Expected Date of Completion:  \expectedcompletetiondate

Laboratory where thesis will be done: CSAIL

Brief Statement of the Problem:

\briefproblemstatement 

 \newpage }

\begin{document}

\thesisproposalform

\newpage

\section{Introduction}

Technical computing is an especially rich application area for programming
languages to address. The observation that a language ``is likely to be used to
solve problems which its designer did not envision'' \cite{Liskov:1974pb}
applies doubly: the programmers are domain experts, and are likely to be
doing original research.

A current popular approach is to start with an existing high-level language
that has a degree of acceptance and popularity. From there, a wide variety
of techniques can be deployed to improve performance. Many of these ask for
no source modification: static analysis, JIT compilation, tracing, or
moving more functionality into low-level libraries. Some techniques involve
slight source modifications: optional type annotations, decorators that
invoke code transformations, or alternate ``dialects'' such as Cython
\cite{Behnel:2011}.

These techniques all have value. For most applications they are a boon.
In the case of JavaScript, for example, they have transformed the web
dramatically. However, technical computing is a bit different, and for
this application area two significant problems remain:

\begin{enumerate}
\item The performance ceiling. Speculative optimizations require
run-time checks, making it difficult to fully match the performance of
statically-compiled languages (C, C++, Fortran).

\item Flexibility. The most important operations in technical computing
have a particularly uncooperative combination of characteristics:
they are highly polymorphic, the fine details of their behavior are
crucial to performance, and their binding time requirements
vary by application.
\end{enumerate}

These three characteristics are best explained through quick examples:

\begin{enumerate}
\item Polymorphism: array indexing accepts any number of arguments, each of
which may be of several different types.

\item Crucial details: the rank of an array must be statically known to fully
unroll index computations.

\item Binding time: in some applications array ranks are only known at run
time.
\end{enumerate}

Many other instances of these problems exist. In general, technical
computing is so diverse and exploratory that it is common for a language's
binding time decisions or type domains not to correspond to those
relevant to a particular technical application.

\newpage

\bibliographystyle{plain}
\bibliography{proposal}

\end{document}
